{"version":3,"sources":["node_modules/browser-pack/_prelude.js","lib/browser/base64.js","lib/browser/request.js","lib/browser/source.js","lib/browser/storage.js","lib/error.js","lib/fingerprint.js","lib/index.js","lib/upload.js","node_modules/extend/index.js","node_modules/resolve-url/resolve-url.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","tus","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_dereq_","encode","btoa","data","unescape","encodeURIComponent","isSupported","newRequest","resolveUrl","_resolveUrl","XMLHttpRequest","origin","link","_resolveUrl2","default","getSource","FileSource","file","_classCallCheck","_file","size","start","end","slice","input","setItem","getItem","removeItem","hasStorage","key","localStorage","SECURITY_ERR","QUOTA_EXCEEDED_ERR","canStoreURLs","value","DetailedError","error","causingErr","arguments","undefined","xhr","_this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","message","originalRequest","causingError","toString","status","responseText","fingerprint","name","type","lastModified","join","_upload","_storage","defaultOptions","_window","Blob","prototype","Upload","_upload2","_fingerprint","_error","_extend","_request","_source","_base","Base64","Storage","endpoint","_fingerprint2","resume","onProgress","onChunkComplete","onSuccess","onError","headers","chunkSize","Infinity","withCredentials","uploadUrl","uploadSize","overridePatchMethod","retryDelays","options","_extend2","url","_xhr","_offset","_aborted","_size","_retryAttempt","_retryTimeout","_offsetBeforeRetry","_emitError","source","isNaN","errorCallback","err","shouldResetDelays","isOnline","navigator","onLine","shouldRetry","inStatusCategory","delay","setTimeout","_resumeUpload","resumedUrl","_createUpload","abort","close","clearTimeout","_this2","onabort","_cancelUpload","_error2","_emitCancelError","onCancelError","onCancelSuccess","bytesSent","bytesTotal","bytesAccepted","setRequestHeader","_this3","open","onload","_emitXhrError","getResponseHeader","_startUpload","onerror","_setupXHR","metadata","encodeMetadata","send","_this4","_emitonCancelSuccess","_emitXhrCancelError","_this5","offset","parseInt","_emitProgress","_emitSuccess","_this6","_emitChunkComplete","upload","onprogress","lengthComputable","loaded","encoded","push","category","hasOwn","hasOwnProperty","toStr","isArray","arr","Array","isPlainObject","obj","hasOwnConstructor","hasIsPrototypeOf","constructor","extend","src","copy","copyIsArray","clone","target","deep","root","factory","numUrls","base","document","createElement","href","head","getElementsByTagName","insertBefore","firstChild","resolved","index","removeChild"],"mappings":"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","file":"./dist/tus.min.js","sourceRoot":"","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* global: window */\n\nconst {btoa} = window;\n\nexport function encode(data) {\n  return btoa(unescape(encodeURIComponent(data)));\n}\n\nexport const isSupported = \"btoa\" in window;\n","/* global window */\nimport resolve from \"resolve-url\";\n\nexport function newRequest() {\n  return new window.XMLHttpRequest();\n}\n\nexport function resolveUrl(origin, link) {\n  return resolve(origin, link);\n}\n","class FileSource {\n  constructor(file) {\n    this._file = file;\n    this.size = file.size;\n  }\n\n  slice(start, end) {\n    return this._file.slice(start, end);\n  }\n\n  close() {}\n}\n\nexport function getSource(input) {\n  // Since we emulate the Blob type in our tests (not all target browsers\n  // support it), we cannot use `instanceof` for testing whether the input value\n  // can be handled. Instead, we simply check is the slice() function and the\n  // size property are available.\n  if (typeof input.slice === \"function\" && typeof input.size !== \"undefined\") {\n    return new FileSource(input);\n  }\n\n  throw new Error(\"source object may only be an instance of File or Blob in this environment\");\n}\n","/* global window, localStorage */\n\nlet hasStorage = false;\ntry {\n  hasStorage = \"localStorage\" in window;\n\n  // Attempt to store and read entries from the local storage to detect Private\n  // Mode on Safari on iOS (see #49)\n  var key = \"tusSupport\";\n  localStorage.setItem(key, localStorage.getItem(key));\n\n} catch (e) {\n  // If we try to access localStorage inside a sandboxed iframe, a SecurityError\n  // is thrown. When in private mode on iOS Safari, a QuotaExceededError is\n  // thrown (see #49)\n  if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) {\n    hasStorage = false;\n  } else {\n    throw e;\n  }\n}\n\nexport const canStoreURLs = hasStorage;\n\nexport function setItem(key, value) {\n  if (!hasStorage) return;\n  return localStorage.setItem(key, value);\n}\n\nexport function getItem(key) {\n  if (!hasStorage) return;\n  return localStorage.getItem(key);\n}\n\nexport function removeItem(key) {\n  if (!hasStorage) return;\n  return localStorage.removeItem(key);\n}\n","class DetailedError extends Error {\n  constructor(error, causingErr = null, xhr = null) {\n    super(error.message);\n\n    this.originalRequest = xhr;\n    this.causingError = causingErr;\n\n    let message = error.message;\n    if (causingErr != null) {\n      message += `, caused by ${causingErr.toString()}`;\n    }\n    if (xhr != null) {\n      message += `, originated from request (response code: ${xhr.status}, response text: ${xhr.responseText})`;\n    }\n    this.message = message;\n  }\n}\n\nexport default DetailedError;\n","/**\n * Generate a fingerprint for a file which will be used the store the endpoint\n *\n * @param {File} file\n * @return {String}\n */\nexport default function fingerprint(file) {\n  return [\n\t\t\"tus\",\n\t\tfile.name,\n\t\tfile.type,\n\t\tfile.size,\n\t\tfile.lastModified\n  ].join(\"-\");\n}\n","/* global window */\nimport Upload from \"./upload\";\nimport {canStoreURLs} from \"./node/storage\";\n\nconst {defaultOptions} = Upload;\n\nif (typeof window !== \"undefined\") {\n  // Browser environment using XMLHttpRequest\n  const {XMLHttpRequest, Blob} = window;\n\n  var isSupported = (\n    XMLHttpRequest &&\n    Blob &&\n    typeof Blob.prototype.slice === \"function\"\n  );\n} else {\n  // Node.js environment using http module\n  var isSupported = true;\n}\n\n// The usage of the commonjs exporting syntax instead of the new ECMAScript\n// one is actually inteded and prevents weird behaviour if we are trying to\n// import this module in another module using Babel.\nmodule.exports = {\n  Upload,\n  isSupported,\n  canStoreURLs,\n  defaultOptions\n};\n","/* global window */\nimport fingerprint from \"./fingerprint\";\nimport DetailedError from \"./error\";\nimport extend from \"extend\";\n\n// We import the files used inside the Node environment which are rewritten\n// for browsers using the rules defined in the package.json\nimport {newRequest, resolveUrl} from \"./node/request\";\nimport {getSource} from \"./node/source\";\nimport * as Base64 from \"./node/base64\";\nimport * as Storage from \"./node/storage\";\n\nconst defaultOptions = {\n  endpoint: \"\",\n  fingerprint,\n  resume: true,\n  onProgress: null,\n  onChunkComplete: null,\n  onSuccess: null,\n  onError: null,\n  headers: {},\n  chunkSize: Infinity,\n  withCredentials: false,\n  uploadUrl: null,\n  uploadSize: null,\n  overridePatchMethod: false,\n  retryDelays: null\n};\n\nclass Upload {\n  constructor(file, options) {\n    this.options = extend(true, {}, defaultOptions, options);\n\n    // The underlying File/Blob object\n    this.file = file;\n\n    // The URL against which the file will be uploaded\n    this.url = null;\n\n    // The underlying XHR object for the current PATCH request\n    this._xhr = null;\n\n    // The fingerpinrt for the current file (set after start())\n    this._fingerprint = null;\n\n    // The offset used in the current PATCH request\n    this._offset = null;\n\n    // True if the current PATCH request has been aborted\n    this._aborted = false;\n\n    // The file's size in bytes\n    this._size = null;\n\n    // The Source object which will wrap around the given file and provides us\n    // with a unified interface for getting its size and slice chunks from its\n    // content allowing us to easily handle Files, Blobs, Buffers and Streams.\n    this._source = null;\n\n    // The current count of attempts which have been made. Null indicates none.\n    this._retryAttempt = 0;\n\n    // The timeout's ID which is used to delay the next retry\n    this._retryTimeout = null;\n\n    // The offset of the remote upload before the latest attempt was started.\n    this._offsetBeforeRetry = 0;\n  }\n\n  start() {\n    let file = this.file;\n\n    if (!file) {\n      this._emitError(new Error(\"tus: no file or stream to upload provided\"));\n      return;\n    }\n\n    if (!this.options.endpoint) {\n        this._emitError(new Error(\"tus: no endpoint provided\"));\n        return;\n    }\n\n    let source = this._source = getSource(file, this.options.chunkSize);\n\n    // Firstly, check if the caller has supplied a manual upload size or else\n    // we will use the calculated size by the source object.\n    if (this.options.uploadSize != null) {\n      let size = +this.options.uploadSize;\n      if (isNaN(size)) {\n        throw new Error(\"tus: cannot convert `uploadSize` option into a number\");\n      }\n\n      this._size = size;\n    } else {\n      let size = source.size;\n\n      // The size property will be null if we cannot calculate the file's size,\n      // for example if you handle a stream.\n      if (size == null) {\n        throw new Error(\"tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option\");\n      }\n\n      this._size = size;\n    }\n\n    let retryDelays = this.options.retryDelays;\n    if (retryDelays != null) {\n      if (Object.prototype.toString.call(retryDelays) !== \"[object Array]\") {\n        throw new Error(\"tus: the `retryDelays` option must either be an array or null\");\n      } else {\n        let errorCallback = this.options.onError;\n        this.options.onError = (err) => {\n          // Restore the original error callback which may have been set.\n          this.options.onError = errorCallback;\n\n          // We will reset the attempt counter if\n          // - we were already able to connect to the server (offset != null) and\n          // - we were able to upload a small chunk of data to the server\n          let shouldResetDelays = this._offset != null && (this._offset > this._offsetBeforeRetry);\n          if (shouldResetDelays) {\n            this._retryAttempt = 0;\n          }\n\n          let isOnline = true;\n          if (typeof window !== \"undefined\" &&\n             \"navigator\" in window &&\n             window.navigator.onLine === false) {\n               isOnline = false;\n             }\n\n          // We only attempt a retry if\n          // - we didn't exceed the maxium number of retries, yet, and\n          // - this error was caused by a request or it's response and\n          // - the error is not a client error (status 4xx) and\n          // - the browser does not indicate that we are offline\n          let shouldRetry = this._retryAttempt < retryDelays.length &&\n                            err.originalRequest != null &&\n                            !inStatusCategory(err.originalRequest.status, 400) &&\n                            isOnline;\n\n          if (!shouldRetry) {\n            this._emitError(err);\n            return;\n          }\n\n          let delay = retryDelays[this._retryAttempt++];\n\n          this._offsetBeforeRetry = this._offset;\n          this.options.uploadUrl = this.url;\n\n          this._retryTimeout = setTimeout(() => {\n            this.start();\n          }, delay);\n        };\n      }\n    }\n\n    // Reset the aborted flag when the upload is started or else the\n    // _startUpload will stop before sending a request if the upload has been\n    // aborted previously.\n    this._aborted = false;\n\n    // A URL has manually been specified, so we try to resume\n    if (this.options.uploadUrl != null) {\n        this.url = this.options.uploadUrl;\n        this._resumeUpload();\n        return;\n    }\n\n    // Try to find the endpoint for the file in the storage\n    if (this.options.resume) {\n        this._fingerprint = this.options.fingerprint(file);\n        let resumedUrl = Storage.getItem(this._fingerprint);\n\n        if (resumedUrl != null) {\n            this.url = resumedUrl;\n            this._resumeUpload();\n            return;\n        }\n    }\n\n    // An upload has not started for the file yet, so we start a new one\n    this._createUpload();\n  }\n\n  abort() {\n    if (this._xhr !== null) {\n      this._xhr.abort();\n      this._source.close();\n      this._aborted = true;\n    }\n\n    if (this._retryTimeout != null) {\n      clearTimeout(this._retryTimeout);\n      this._retryTimeout = null;\n    }\n  }\n\n  cancel() {\n    if (this._xhr != null && this._aborted == false) {\n      this._xhr.onabort = () => {\n        this._cancelUpload();\n      };\n      this.abort();\n    } else {\n      this._cancelUpload();\n    }\n  }\n\n  _emitXhrError(xhr, err, causingErr) {\n    this._emitError(new DetailedError(err, causingErr, xhr));\n  }\n\n  _emitError(err) {\n    if (typeof this.options.onError === \"function\") {\n      this.options.onError(err);\n    } else {\n      throw err;\n    }\n  }\n\n  _emitXhrCancelError(xhr, err, causingErr) {\n    this._emitCancelError(new DetailedError(err, causingErr, xhr));\n  }\n\n  _emitCancelError(err) {\n    if (typeof this.options.onError === \"function\") {\n      this.options.onCancelError(err);\n    } else {\n      throw err;\n    }\n  }\n\n  _emitSuccess() {\n    if (typeof this.options.onSuccess === \"function\") {\n      this.options.onSuccess();\n    }\n  }\n\n  _emitonCancelSuccess() {\n    if (typeof this.options.onCancelSuccess === \"function\") {\n      this.options.onCancelSuccess();\n    }\n  }\n\n  /**\n   * Publishes notification when data has been sent to the server. This\n   * data may not have been accepted by the server yet.\n   * @param  {number} bytesSent  Number of bytes sent to the server.\n   * @param  {number} bytesTotal Total number of bytes to be sent to the server.\n   */\n  _emitProgress(bytesSent, bytesTotal) {\n    if (typeof this.options.onProgress === \"function\") {\n      this.options.onProgress(bytesSent, bytesTotal);\n    }\n  }\n\n  /**\n   * Publishes notification when a chunk of data has been sent to the server\n   * and accepted by the server.\n   * @param  {number} chunkSize  Size of the chunk that was accepted by the\n   *                             server.\n   * @param  {number} bytesAccepted Total number of bytes that have been\n   *                                accepted by the server.\n   * @param  {number} bytesTotal Total number of bytes to be sent to the server.\n   */\n  _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {\n    if (typeof this.options.onChunkComplete === \"function\") {\n      this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);\n    }\n  }\n\n  /**\n   * Set the headers used in the request and the withCredentials property\n   * as defined in the options\n   *\n   * @param {XMLHttpRequest} xhr\n   */\n  _setupXHR(xhr) {\n    this._xhr = xhr;\n\n    xhr.setRequestHeader(\"Tus-Resumable\", \"1.0.0\");\n    let headers = this.options.headers;\n\n    for (let name in headers) {\n      xhr.setRequestHeader(name, headers[name]);\n    }\n\n    xhr.withCredentials = this.options.withCredentials;\n  }\n\n  /**\n   * Create a new upload using the creation extension by sending a POST\n   * request to the endpoint. After successful creation the file will be\n   * uploaded\n   *\n   * @api private\n   */\n  _createUpload() {\n    let xhr = newRequest();\n    xhr.open(\"POST\", this.options.endpoint, true);\n\n    xhr.onload = () => {\n      if (!inStatusCategory(xhr.status, 200)) {\n        this._emitXhrError(xhr, new Error(\"tus: unexpected response while creating upload\"));\n        return;\n      }\n\n      this.url = resolveUrl(this.options.endpoint, xhr.getResponseHeader(\"Location\"));\n\n      if (this.options.resume) {\n        Storage.setItem(this._fingerprint, this.url);\n      }\n\n      this._offset = 0;\n      this._startUpload();\n    };\n\n    xhr.onerror = (err) => {\n      this._emitXhrError(xhr, new Error(\"tus: failed to create upload\"), err);\n    };\n\n    this._setupXHR(xhr);\n    xhr.setRequestHeader(\"Upload-Length\", this._size);\n\n    // Add metadata if values have been added\n    var metadata = encodeMetadata(this.options.metadata);\n    if (metadata !== \"\") {\n        xhr.setRequestHeader(\"Upload-Metadata\", metadata);\n    }\n\n    xhr.send(null);\n  }\n\n  /**\n   * Cancel upload using the delete extension by sending a DELETE\n   * request to the uploadUrl.\n   *\n   * @api private\n   */\n  _cancelUpload() {\n    let xhr = newRequest();\n    xhr.open(\"DELETE\", this.url, true);\n\n    xhr.onload = () => {\n      if (!inStatusCategory(xhr.status, 200)) {\n        if (xhr.status === 423) {\n          this._cancelUpload();\n          return;\n        }\n\n        if (inStatusCategory(xhr.status, 400)) {\n          Storage.removeItem(this._fingerprint);\n          this._emitonCancelSuccess();\n          return;\n        }\n      }\n\n      Storage.removeItem(this._fingerprint);\n      this._emitonCancelSuccess();\n      return;\n    };\n\n    xhr.onerror = (err) => {\n      this._emitXhrCancelError(xhr, new Error(\"tus: failed to cancel upload\"), err);\n    };\n\n    this._setupXHR(xhr);\n    xhr.send(null);\n  }\n\n  /*\n   * Try to resume an existing upload. First a HEAD request will be sent\n   * to retrieve the offset. If the request fails a new upload will be\n   * created. In the case of a successful response the file will be uploaded.\n   *\n   * @api private\n   */\n  _resumeUpload() {\n    let xhr = newRequest();\n    xhr.open(\"HEAD\", this.url, true);\n\n    xhr.onload = () => {\n      if (!inStatusCategory(xhr.status, 200)) {\n        if (this.options.resume && inStatusCategory(xhr.status, 400)) {\n          // Remove stored fingerprint and corresponding endpoint,\n          // on client errors since the file can not be found\n          Storage.removeItem(this._fingerprint);\n        }\n\n        // If the upload is locked (indicated by the 423 Locked status code), we\n        // emit an error instead of directly starting a new upload. This way the\n        // retry logic can catch the error and will retry the upload. An upload\n        // is usually locked for a short period of time and will be available\n        // afterwards.\n        if (xhr.status === 423) {\n          this._emitXhrError(xhr, new Error(\"tus: upload is currently locked; retry later\"));\n          return;\n        }\n\n        // Try to create a new upload\n        this.url = null;\n        this._createUpload();\n        return;\n      }\n\n      let offset = parseInt(xhr.getResponseHeader(\"Upload-Offset\"), 10);\n      if (isNaN(offset)) {\n        this._emitXhrError(xhr, new Error(\"tus: invalid or missing offset value\"));\n        return;\n      }\n\n      let length = parseInt(xhr.getResponseHeader(\"Upload-Length\"), 10);\n      if (isNaN(length)) {\n        this._emitXhrError(xhr, new Error(\"tus: invalid or missing length value\"));\n        return;\n      }\n\n      // Upload has already been completed and we do not need to send additional\n      // data to the server\n      if (offset === length) {\n        this._emitProgress(length, length);\n        this._emitSuccess();\n        return;\n      }\n\n      this._offset = offset;\n      this._startUpload();\n    };\n\n    xhr.onerror = (err) => {\n      this._emitXhrError(xhr, new Error(\"tus: failed to resume upload\"), err);\n    };\n\n    this._setupXHR(xhr);\n    xhr.send(null);\n  }\n\n  /**\n   * Start uploading the file using PATCH requests. The file will be divided\n   * into chunks as specified in the chunkSize option. During the upload\n   * the onProgress event handler may be invoked multiple times.\n   *\n   * @api private\n   */\n  _startUpload() {\n    // If the upload has been aborted, we will not send the next PATCH request.\n    // This is important if the abort method was called during a callback, such\n    // as onChunkComplete or onProgress.\n    if (this._aborted) {\n      return;\n    }\n\n    let xhr = newRequest();\n\n    // Some browser and servers may not support the PATCH method. For those\n    // cases, you can tell tus-js-client to use a POST request with the\n    // X-HTTP-Method-Override header for simulating a PATCH request.\n    if (this.options.overridePatchMethod) {\n      xhr.open(\"POST\", this.url, true);\n      xhr.setRequestHeader(\"X-HTTP-Method-Override\", \"PATCH\");\n    } else {\n      xhr.open(\"PATCH\", this.url, true);\n    }\n\n    xhr.onload = () => {\n      if (!inStatusCategory(xhr.status, 200)) {\n        this._emitXhrError(xhr, new Error(\"tus: unexpected response while uploading chunk\"));\n        return;\n      }\n\n      let offset = parseInt(xhr.getResponseHeader(\"Upload-Offset\"), 10);\n      if (isNaN(offset)) {\n        this._emitXhrError(xhr, new Error(\"tus: invalid or missing offset value\"));\n        return;\n      }\n\n      this._emitProgress(offset, this._size);\n      this._emitChunkComplete(offset - this._offset, offset, this._size);\n\n      this._offset = offset;\n\n      if (offset == this._size) {\n        // Yay, finally done :)\n        this._emitSuccess();\n        this._source.close();\n        return;\n      }\n\n      this._startUpload();\n    };\n\n    xhr.onerror = (err) => {\n      // Don't emit an error if the upload was aborted manually\n      if (this._aborted) {\n        return;\n      }\n\n      this._emitXhrError(xhr, new Error(\"tus: failed to upload chunk at offset \" + this._offset), err);\n    };\n\n    // Test support for progress events before attaching an event listener\n    if (\"upload\" in xhr) {\n      xhr.upload.onprogress = (e) => {\n        if (!e.lengthComputable) {\n          return;\n        }\n\n        this._emitProgress(start + e.loaded, this._size);\n      };\n    }\n\n    this._setupXHR(xhr);\n\n    xhr.setRequestHeader(\"Upload-Offset\", this._offset);\n    xhr.setRequestHeader(\"Content-Type\", \"application/offset+octet-stream\");\n\n    let start = this._offset;\n    let end = this._offset + this.options.chunkSize;\n\n    // The specified chunkSize may be Infinity or the calcluated end position\n    // may exceed the file's size. In both cases, we limit the end position to\n    // the input's total size for simpler calculations and correctness.\n    if (end === Infinity || end > this._size) {\n      end = this._size;\n    }\n\n    xhr.send(this._source.slice(start, end));\n  }\n\n}\n\nfunction encodeMetadata(metadata) {\n    if (!Base64.isSupported) {\n        return \"\";\n    }\n\n    var encoded = [];\n\n    for (var key in metadata) {\n        encoded.push(key + \" \" + Base64.encode(metadata[key]));\n    }\n\n    return encoded.join(\",\");\n}\n\n/**\n * Checks whether a given status is in the range of the expected category.\n * For example, only a status between 200 and 299 will satisfy the category 200.\n *\n * @api private\n */\nfunction inStatusCategory(status, category) {\n  return (status >= category && status < (category + 100));\n}\n\nUpload.defaultOptions = defaultOptions;\n\nexport default Upload;\n","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","// Copyright 2014 Simon Lydell\r\n// X11 (“MIT”) Licensed. (See LICENSE.)\r\n\r\nvoid (function(root, factory) {\r\n  if (typeof define === \"function\" && define.amd) {\r\n    define(factory)\r\n  } else if (typeof exports === \"object\") {\r\n    module.exports = factory()\r\n  } else {\r\n    root.resolveUrl = factory()\r\n  }\r\n}(this, function() {\r\n\r\n  function resolveUrl(/* ...urls */) {\r\n    var numUrls = arguments.length\r\n\r\n    if (numUrls === 0) {\r\n      throw new Error(\"resolveUrl requires at least one argument; got none.\")\r\n    }\r\n\r\n    var base = document.createElement(\"base\")\r\n    base.href = arguments[0]\r\n\r\n    if (numUrls === 1) {\r\n      return base.href\r\n    }\r\n\r\n    var head = document.getElementsByTagName(\"head\")[0]\r\n    head.insertBefore(base, head.firstChild)\r\n\r\n    var a = document.createElement(\"a\")\r\n    var resolved\r\n\r\n    for (var index = 1; index < numUrls; index++) {\r\n      a.href = arguments[index]\r\n      resolved = a.href\r\n      base.href = resolved\r\n    }\r\n\r\n    head.removeChild(base)\r\n\r\n    return resolved\r\n  }\r\n\r\n  return resolveUrl\r\n\r\n}));\r\n"]}